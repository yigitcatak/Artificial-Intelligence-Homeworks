# -*- coding: utf-8 -*-
"""codeonly.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P588II1JKQEiNpKfLZlddao01KuYYvCO
"""

import queue
import time

def ReadBoard(text):
  targetBoard = "/content/drive/My Drive/CS 404/HW1/" + text
  File = open(targetBoard, 'r')

  Lines = File.readlines()

  xs1 = -1
  xs2 = -1
  Board = []

  print("current board is:\n")
  for r in range(len(Lines)):
    row = Lines[r].strip()
    print(row)

    if "G" in row:
      G = (r, row.replace(" ", "").find("G"))
    if "S" in row:
      if xs1==-1:
        xs1 = r
        ys1 = row.replace(" ", "").find("S")
        if row.count("S")==2:
          xs2 = r
          ys2 = row.replace(" ", "").find("S",ys1+1)

      else:
        xs2 = r
        ys2 = row.replace(" ", "").find("S")

    Board.append(row.split(" "))

  if xs2 == -1: #lies in z plane
    S = (xs1,ys1,xs1,ys1,"z")
  elif xs1==xs2: #lies in x plane
    S = (xs1,ys1,xs2,ys2,"x")
  else: #lies in y plane
    S = (xs1,ys1,xs2,ys2,"y")

  print("\nGoal is at:",G)
  print("Start is at:",S,"\n")

  return (S,G,Board)

class Node:
  def __init__ (self,x1,y1,x2,y2,status,previous=None):
    self.x1 = x1
    self.y1 = y1
    self.x2 = x2
    self.y2 = y2
    self.status = status # "z" = lies on z plane, "x" = lies on x plane, "y" = lies on y plane
    self.previous = previous

##### SHOW STATUS - FOR SELF CHECK
  def SHOW_ME_WHAT_YOU_GOT(self):
    print((self.x1,self.y1,self.x2,self.y2,self.status)) 

##### GET COORDINATES
  def get(self):
    return (self.x1,self.y1,self.x2,self.y2)

##### MOVE UP
  def move_up(self):
    Temp = Node(self.x1,self.y1,self.x2,self.y2,self.status,self)

    # when moving up from status "y", north point should move 1 and the other 2
    x1 = self.x1
    x2 = self.x2

    if self.status=="z":
      if (self.x1 - 2 >= 0) and (Board[self.x1-1][self.y1] != "X") and (Board[self.x2-2][self.y2] != "X"):
        Temp.x1 -= 1
        Temp.x2 -= 2
        Temp.status = "y"
        return Temp

    elif self.status=="x":
      if (self.x1 - 1 >= 0) and (Board[self.x1-1][self.y1] != "X") and (Board[self.x2-1][self.y2] != "X"):
        Temp.x1 -= 1
        Temp.x2 -= 1
        return Temp
    
    else: #self.status=="y"
      if (min(x1,x2) - 1 >= 0) and (Board[min(x1,x2) - 1][self.y1] != "X"):
        Temp.x1 = min(x1,x2)-1
        Temp.x2 = Temp.x1
        Temp.status = "z"
        return Temp

##### MOVE DOWN
  def move_down(self):
    Temp = Node(self.x1,self.y1,self.x2,self.y2,self.status,self)

    # when moving down from status "y", south point should move 1 and the other 2
    x1 = self.x1
    x2 = self.x2

    if self.status=="z":
      if (self.x1 + 2 < len(Board)) and (Board[self.x1+1][self.y1] != "X") and (Board[self.x2+2][self.y2] != "X"):
        Temp.x1 += 1
        Temp.x2 += 2
        Temp.status = "y"
        return Temp

    elif self.status=="x":
      if (self.x1 + 1 < len(Board)) and (Board[self.x1+1][self.y1] != "X") and (Board[self.x2+1][self.y2] != "X"):
        Temp.x1 += 1
        Temp.x2 += 1
        return Temp
    
    else: #self.status=="y"
      if (max(x1,x2) + 1 < len(Board)) and (Board[max(x1,x2)+1][self.y1] != "X"):
        Temp.x1 = max(x1,x2)+1
        Temp.x2 = Temp.x1
        Temp.status = "z"
        return Temp

##### MOVE RIGHT
  def move_right(self):
    Temp = Node(self.x1,self.y1,self.x2,self.y2,self.status,self)

    # when moving right from status "x", east point should move 1 and the other 2
    y1 = self.y1
    y2 = self.y2

    if self.status=="z":
      if (self.y1+2 < len(Board[0])) and (Board[self.x1][self.y1+1] != "X") and (Board[self.x2][self.y2+2] != "X"):
        Temp.y1 += 1
        Temp.y2 += 2
        Temp.status = "x"
        return Temp

    elif self.status=="x":
      if (max(y1,y2) + 1 < len(Board[0])) and (Board[self.x1][max(y1,y2)+1] != "X"):
        Temp.y1 = max(y1,y2)+1
        Temp.y2 = Temp.y1
        Temp.status = "z"
        return Temp
    
    else: #self.status=="y"
      if (self.y1 + 1 < len(Board[0])) and (Board[self.x1][self.y1+1] != "X") and (Board[self.x2][self.y2+1] != "X"):
        Temp.y1 += 1
        Temp.y2 += 1
        return Temp

##### MOVE LEFT
  def move_left(self):
    Temp = Node(self.x1,self.y1,self.x2,self.y2,self.status,self)

    # when moving left from status "x", west point should move 1 and the other 2
    y1 = self.y1
    y2 = self.y2

    if self.status=="z":
      if (self.y1 - 2 >= 0) and (Board[self.x1][self.y1-1] != "X") and (Board[self.x2][self.y2-2] != "X"):
        Temp.y1 -= 1
        Temp.y2 -= 2
        Temp.status = "x"
        return Temp
    
    elif self.status=="x":
      if (min(y1,y2) - 1 >= 0) and (Board[self.x1][min(y1,y2)+1] != "X"):
        Temp.y1 = min(y1,y2)-1
        Temp.y2 = Temp.y1
        Temp.status = "z"
        return Temp
    
    else: #self.status=="y"
      if (self.y1 - 1 >= 0) and (Board[self.x1][self.y1-1] != "X") and (Board[self.x2][self.y2-1] != "X"):
        Temp.y1 -= 1
        Temp.y2 -= 1
        return Temp

##### GOAL CHECK
  def is_goal(self, G):
    if (self.status == "z") and ((self.x1, self.y1) == G):
      return True
    return False

def success(node):

  Path = []
  if node.previous == None:
    print("Start and Goal is same")
    
  while node.previous != None:
    Path.insert(0,node)
    node = node.previous
  Path.insert(0,node)

  moves = len(Path)-1
  print("path found as following, with %s moves (including start at the beginning and goal at the end):\n" %moves)

  for state in Path:
    print(state.get())
  print()

def isnot_visited(node,visited):
  for i in visited:
    # 2 cubes interpretation, as we don't track which cube is which we should check their switched positions as they give the same state too
    # meaning positioning would be same for two nodes (x1,y1,x2,y2) and (x2,y2,x1,y1) inreality

    # initially overridden equality symbol (__eq__) in class to check this however it also overwrites not equal sign (__ne__) 
    # and it interrupted my further check if node is not equal to None, as I couldn't implent it inside class and didn't want to spend time with it
    # and found writing 8 equality check here is easier
    
    if ((node.x1 == i.x1) and (node.x2 == i.x2) and (node.y1 == i.y1) and (node.y2 == i.y2)) or \
    ((node.x1 == i.x2) and (node.x2 == i.x1) and (node.y1 == i.y2) and (node.y2 == i.y1)):
      return False
  return True

def insert_to_UCS(node,Q):
  if not (node in Q.queue):
    Q.put(node)
    return True # so that frontier size will be increased
  return False # so that frontier size Will NOT be increased

def UCS(S,G,Board):
  start_time = time.time()

  Start = Node(S[0],S[1],S[2],S[3],S[4])
  Q = queue.Queue()
  Q.put(Start)
  total_explored = 1

  visited = []

  while not Q.empty():
    A = Q.get()
    if A.is_goal(G):
      success(A)
      break

    visited.append(A)

    B = A.move_up()
    if (B!=None) and (isnot_visited(B,visited)): #if B == None executement will stop, so it is safe
      if insert_to_UCS(B,Q): #if node is insertable it will insert and return True
        total_explored += 1 

    B = A.move_right()
    if (B!=None) and (isnot_visited(B,visited)):
      if insert_to_UCS(B,Q):
        total_explored += 1
    
    B = A.move_down()
    if (B!=None) and (isnot_visited(B,visited)):
      if insert_to_UCS(B,Q):
        total_explored += 1 
    
    B = A.move_left()
    if (B!=None) and (isnot_visited(B,visited)):
      if insert_to_UCS(B,Q):
        total_explored += 1 

  print("execution completed in %s seconds" % (time.time() - start_time))
  print("total frontier size reached (explored and saved nodes on memmory): %s" % total_explored)

def UCS2(S,G,Board):
  start_time = time.time()

  Start = Node(S[0],S[1],S[2],S[3],S[4])
  Q = queue.Queue()
  Q.put(Start)
  total_explored = 1
  
  while not Q.empty():
    A = Q.get()
    if A.is_goal(G):
      success(A)
      break

    B = A.move_up()
    if (B!=None): #if B == None executement will stop, so it is safe
      Q.put(B)
      total_explored += 1

    B = A.move_right()
    if (B!=None):
      Q.put(B)
      total_explored += 1
    
    B = A.move_down()
    if (B!=None):
      Q.put(B)
      total_explored += 1
    
    B = A.move_left()
    if (B!=None):
      Q.put(B)
      total_explored += 1

  print("execution completed in %s seconds" % (time.time() - start_time))
  print("total frontier size reached (explored and saved nodes on memmory): %s" % total_explored)

def h(node,G):
  a = abs(node.x1-G[0]) + abs(node.y1-G[1])
  b = abs(node.x2-G[0]) + abs(node.y2-G[1])
  return min(a,b)

def g(node):
  a = 0
  while node.previous != None:
    a += 1
    node = node.previous
      
  return a*2

def insert_to_ASS(newNodeTuple,Q):

  if Q.empty():
    Q.put(newNodeTuple)
    return

  tempNodeList = []
  while not Q.empty():
    tempNodeTuple = Q.get()

    #once again if nodes are at same position/status
    if ((newNodeTuple[2].x1 == tempNodeTuple[2].x1) and (newNodeTuple[2].x2 == tempNodeTuple[2].x2) and \
    (newNodeTuple[2].y1 == tempNodeTuple[2].y1) and (newNodeTuple[2].y2 == tempNodeTuple[2].y2)) or \
    ((newNodeTuple[2].x1 == tempNodeTuple[2].x2) and (newNodeTuple[2].x2 == tempNodeTuple[2].x1) and \
    (newNodeTuple[2].y1 == tempNodeTuple[2].y2) and (newNodeTuple[2].y2 == tempNodeTuple[2].y1)):

      if newNodeTuple[0] < tempNodeTuple[0]: #if same node found and if the newly explored node has a lower cost
        Q.put(newNodeTuple) #put the new node instead of the higher cost one

      else: #if the same node in the queue has a lower or equal cost to the newly explored node there is no need to put the
      #new node to the queue as same position will give same heuristic and if costs are same it means they took equal moves as well.
      #So, we only need to generate one valid shortest path from the begining to the goal, having multiple alternative paths with 
      #same cost are unnecessary so I don't add the same cost. Put back the temporary element for next for loop below
        Q.put(tempNodeTuple)

      for tuples in tempNodeList: # revert the queue as we found the same node and took the required action
      # since this is a priority queue, we don't need to extract everything to keep the sorting of the queue
      # as elements are already inserted sorted based on the cost value 
        Q.put(tuples)

      #return true so that total explored node count will be increased, Either we change the old node with new one
      #or discard the new one, we don't keep the track of the discarded one and the saved node count in memmory is same
      return False

    else: #if the extracted element from queue is not same as the newly explored node
    #just store the extracted node and continue iterating
      tempNodeList.append(tempNodeTuple)
  
  #if queue is emptied and no match found put everything back along with new node
  #return true so that total explored node count will be increased

  for tuples in tempNodeList:
    Q.put(tuples)
  Q.put(newNodeTuple)
  return True

def ASS(S,G,Board):
  start_time = time.time()

  Start = Node(S[0],S[1],S[2],S[3],S[4])
  Q = queue.PriorityQueue()

  uniqueCounter = 0 
  total_explored = 1

  Q.put((0,uniqueCounter,Start)) #as this element will be popped as soon as we went in loop, putting it without cost does not affect the sorting
  # including uniqueCounter in the queue tuple due to the evaluating algorithm of PriorityQueue() from queue library
  # it ensures that if there are 2 nodes with the same cost, firstly explored one will be expanded 
  # (since priority queue will check the secon element of the tuple once the first elements are same)
  visited = []
  

  while not Q.empty():
    A = Q.get()[2]
    if A.is_goal(G):
      success(A)
      break

    visited.append(A)
  
    B = A.move_up()
    if (B!=None) and (isnot_visited(B,visited)): #if B == None executement will stop, so it is safe
      f = g(B) + h(B,G)
      uniqueCounter += 1
      if insert_to_ASS((f,uniqueCounter,B),Q): #if node is insertable it will insert and return True
        total_explored += 1

    B = A.move_right() 
    if (B!=None) and (isnot_visited(B,visited)):
      f = g(B) + h(B,G)
      uniqueCounter += 1
      if insert_to_ASS((f,uniqueCounter,B),Q):
        total_explored += 1
    
    B = A.move_down()
    if (B!=None) and (isnot_visited(B,visited)):
      f = g(B) + h(B,G)
      uniqueCounter += 1
      if insert_to_ASS((f,uniqueCounter,B),Q):
        total_explored += 1  
    
    B = A.move_left()
    if (B!=None) and (isnot_visited(B,visited)):
      f = g(B) + h(B,G)
      uniqueCounter += 1
      if insert_to_ASS((f,uniqueCounter,B),Q):
        total_explored += 1

  print("execution completed in %s seconds" % (time.time() - start_time))
  print("total frontier size reached (explored and saved nodes on memmory): %s" % total_explored)

def ASS2(S,G,Board):
  start_time = time.time()

  Start = Node(S[0],S[1],S[2],S[3],S[4])
  Q = queue.PriorityQueue()

  total_explored = 1 
  Q.put((0,total_explored,Start))

  while not Q.empty():
    A = Q.get()[2]
    if A.is_goal(G):
      success(A)
      break
  
    B = A.move_up()
    if (B!=None): #if B == None executement will stop, so it is safe
      f = g(B) + h(B,G)
      total_explored += 1
      Q.put((f,total_explored,B))

    B = A.move_right() 
    if (B!=None):
      f = g(B) + h(B,G)
      total_explored += 1
      Q.put((f,total_explored,B))
    
    B = A.move_down()
    if (B!=None):
      f = g(B) + h(B,G)
      total_explored += 1
      Q.put((f,total_explored,B))  
    
    B = A.move_left()
    if (B!=None):
      f = g(B) + h(B,G)
      total_explored += 1
      Q.put((f,total_explored,B))

  print("execution completed in %s seconds" % (time.time() - start_time))
  print("total frontier size reached (explored and saved nodes on memmory): %s" % total_explored)

A = ReadBoard("Board1.txt")
S = A[0]
G = A[1]
Board = A[2]

print("\n\nUCS algorithm with visited tile tracking")
UCS(S,G,Board)
print("\n\nUCS algorithm with NO visited tile tracking")
UCS2(S,G,Board)
print("\n\nA* Search algorithm with visited tile tracking")
ASS(S,G,Board)
print("\n\nA* Search algorithm with NO visited tile tracking")
ASS2(S,G,Board)